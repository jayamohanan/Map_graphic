<!-- README: Increment version number every time you update this file -->
<!DOCTYPE html>
<html>
<head>
  <title>Kerala Local Bodies Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #map { width: 100%; height: calc(100vh - 90px); }
    #controls { display: grid; grid-template-columns: 1fr auto auto auto auto; gap: 8px; align-items: center; padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ccc; }
    #controls .row { display: contents; }
    input[type="text"] { width: 100%; padding: 6px 8px; }
    input[type="color"] { padding: 0; border: none; width: 40px; height: 32px; cursor: pointer; }
    button { padding: 6px 10px; }
    small.hint { grid-column: 1 / -1; color: #555; margin-top: -4px; }
    #version { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 5px 10px; border-radius: 5px; font-size: 12px; border: 1px solid #ccc; z-index: 1000; }
    #status { padding: 6px 10px; background: rgba(255,255,255,0.9); border-radius: 5px; position: absolute; bottom: 20px; left: 20px; z-index: 1000; display: none; }
    .separator { grid-column: 1 / -1; height: 1px; background: #e5e5e5; margin: 4px 0; }
  </style>
</head>
<body>
  <div id="controls">
    <!-- Local Bodies Controls -->
    <div class="row">
      <input type="text" id="idInput" placeholder="Enter Local Body Wikidata IDs (comma separated)" />
      <input type="color" id="colorPicker" value="#0000ff" title="Local body fill/border" />
      <input type="color" id="outlineColorPicker" value="#ff0000" title="Union outline color" />
      <button id="drawLB">Draw</button>
      <button id="drawLBOutline">Draw Outline</button>
    </div>
    <small class="hint">Tip: IDs are matched against <code>wikidata</code> property in <code>local_bodies.geojson</code>.</small>

    <div class="separator"></div>

    <!-- Assembly Controls -->
    <div class="row">
      <input type="text" id="asmInput" placeholder="Enter Assembly IDs or Names (comma separated)" />
      <input type="color" id="asmColorPicker" value="#008000" title="Assembly border/fill" />
      <span style="white-space:nowrap;">Thickness +20%</span>
      <button id="drawASM">Draw Assembly</button>
      <button id="clearAll">Clear All</button>
    </div>
    <small class="hint">Assemblies are read from <code>assembly12_V3.geojson</code>. Matching tries common keys: <code>wikidata, ac_id, id, code, ac_name, name, Name</code> (case-insensitive). Names match loosely.</small>
  </div>
  
  <div id="map"></div>
  <div id="version">Version: v2.5</div>
  <div id="status"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/martinez-polygon-clipping/dist/martinez.min.js"></script>

  <script>
    const map = L.map('map', { center: [10.2, 76.4], zoom: 8 });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

    const URLS = {
      localBodies: 'local_bodies.geojson',
      assembly: 'assembly12_V3.geojson',
    };

    let geojsonDataLB = null;
    let geojsonDataASM = null;

    let layerLB = null;
    let layerLBOutline = null;
    let layerASM = null;

    const idInput = document.getElementById('idInput');
    const colorPicker = document.getElementById('colorPicker');
    const outlineColorPicker = document.getElementById('outlineColorPicker');
    const asmInput = document.getElementById('asmInput');
    const asmColorPicker = document.getElementById('asmColorPicker');

    const defaultIDs = ["Q13112599","Q13113111","Q13113059","Q13110970","Q13110239","Q13111922","Q6958393","Q16909824"];
    idInput.value = defaultIDs.join(',');

    function showStatus(message, type = 'info', timeout = 3000) {
      const el = document.getElementById('status');
      el.textContent = message;
      el.style.display = 'block';
      el.style.backgroundColor = type === 'error' ? 'rgba(255,200,200,0.95)' : type === 'warning' ? 'rgba(255,240,200,0.95)' : 'rgba(255,255,255,0.95)';
      if (timeout > 0) setTimeout(() => el.style.display = 'none', timeout);
    }

    async function loadGeoJSON(url, label) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        return await res.json();
      } catch (err) {
        showStatus(`Error loading ${label}: ${err.message}`, 'error', 6000);
        return null;
      }
    }

    function getMatchingFeatures(data, idsOrNames, keys) {
      const want = new Set(idsOrNames.map(s => s.toLowerCase()));
      return data.features.filter(f => {
        for (const k of keys) {
          if (f.properties && f.properties[k] != null) {
            const v = String(f.properties[k]).toLowerCase();
            if (want.has(v)) return true;
          }
        }
        return false;
      });
    }

    function parseCSV(input) {
      return input.split(',').map(s => s.trim()).filter(Boolean);
    }

    function fitIfValid(layer) {
      const b = layer.getBounds && layer.getBounds();
      if (b && b.isValid()) map.fitBounds(b);
    }

    function removeIf(layer) { if (layer) { map.removeLayer(layer); } }

    function drawSelected() {
      const ids = parseCSV(idInput.value);
      const color = colorPicker.value;
      const lbWeight = 2;

      removeIf(layerLB);
      removeIf(layerLBOutline);

      if (!geojsonDataLB) { showStatus('Local bodies not loaded yet', 'error'); return; }

      try {
        const features = geojsonDataLB.features.filter(f => ids.includes(String(f.properties?.wikidata)));
        if (!features.length) { showStatus('No local bodies found for provided IDs', 'warning'); return; }

        layerLB = L.geoJSON(features, { style: { color, weight: lbWeight, fillOpacity: 0.12, fillColor: color } }).addTo(map);
        fitIfValid(layerLB);
        showStatus(`Displayed ${features.length} local bodies.`);

        if (layerASM) applyAssemblyThickness(lbWeight);
      } catch (err) {
        showStatus('Error drawing local bodies: ' + err.message, 'error');
      }
    }

    function drawOutline() {
      if (!layerLB) { showStatus('Please draw local bodies first', 'error'); return; }

      const outlineColor = outlineColorPicker.value;
      removeIf(layerLBOutline);
      showStatus('Calculating outline...');

      try {
        const polygons = [];
        layerLB.eachLayer(layer => {
          const geom = layer.feature.geometry;
          if (geom.type === 'Polygon') polygons.push(geom.coordinates);
          else if (geom.type === 'MultiPolygon') geom.coordinates.forEach(p => polygons.push(p));
        });
        if (!polygons.length) { showStatus('No polygons found to outline', 'warning'); return; }

        let merged = polygons[0];
        for (let i = 1; i < polygons.length; i++) {
          try { merged = martinez.union(merged, polygons[i]); } catch (e) { console.error('Union error', e); }
        }

        const features = [];
        const isValid = (c) => Array.isArray(c) && c.length && Array.isArray(c[0]) && Array.isArray(c[0][0]) && c[0][0].length >= 2;
        if (isValid(merged)) features.push({ type: 'Feature', geometry: { type: 'Polygon', coordinates: merged }, properties: {} });
        else if (Array.isArray(merged)) merged.forEach(poly => { if (isValid(poly)) features.push({ type: 'Feature', geometry: { type: 'Polygon', coordinates: poly }, properties: {} }); });
        if (!features.length) { showStatus('Failed to create valid outline', 'warning'); return; }

        layerLBOutline = L.geoJSON({ type: 'FeatureCollection', features }, { style: { color: outlineColor, weight: 3, fillOpacity: 0, fillColor: outlineColor } }).addTo(map);
        fitIfValid(layerLBOutline);
        showStatus('Outline created successfully');
      } catch (err) {
        showStatus('Error creating outline: ' + err.message, 'error');
      }
    }

    function applyAssemblyThickness(lbWeightBase = 2) {
      if (!layerASM) return;
      const asmWeight = +(lbWeightBase * 1.2).toFixed(2);
      layerASM.setStyle({ weight: asmWeight });
    }

    function drawAssembly() {
      const keys = ['wikidata','WIKIDATA','ac_id','AC_ID','id','ID','code','CODE','ac_name','AC_NAME','name','NAME','Name'];
      const tokens = parseCSV(asmInput.value).map(s => s.toLowerCase());
      const color = asmColorPicker.value;

      removeIf(layerASM);

      if (!geojsonDataASM) { showStatus('Assembly GeoJSON not loaded', 'error'); return; }
      if (!tokens.length) { showStatus('Enter Assembly IDs or names', 'warning'); return; }

      try {
        let feats = getMatchingFeatures(geojsonDataASM, tokens, keys);
        if (!feats.length) {
          feats = geojsonDataASM.features.filter(f => keys.some(k => f.properties?.[k] && tokens.some(t => String(f.properties[k]).toLowerCase().includes(t))));
        }
        if (!feats.length) { showStatus('No assemblies matched the given IDs/names', 'warning'); return; }

        const lbWeight = layerLB ? layerLB.options?.style?.weight || 2 : 2;
        const asmWeight = +(lbWeight * 1.2).toFixed(2);

        layerASM = L.geoJSON(feats, { style: { color, weight: asmWeight, fillOpacity: 0.05, fillColor: color } }).addTo(map);
        fitIfValid(layerASM);
        showStatus(`Displayed ${feats.length} assembly boundary(ies) at +20% thickness.`);
      } catch (err) {
        showStatus('Error drawing assemblies: ' + err.message, 'error');
      }
    }

    function clearAll() {
      [layerLB, layerLBOutline, layerASM].forEach(removeIf);
      layerLB = layerLBOutline = layerASM = null;
      showStatus('Cleared all layers');
    }

    Promise.all([
      loadGeoJSON(URLS.localBodies, 'Local Bodies'),
      loadGeoJSON(URLS.assembly, 'Assembly')
    ]).then(([lb, asm]) => {
      geojsonDataLB = lb; geojsonDataASM = asm;
      if (geojsonDataLB) drawSelected();
    });

    document.getElementById('drawLB').addEventListener('click', drawSelected);
    document.getElementById('drawLBOutline').addEventListener('click', drawOutline);
    document.getElementById('drawASM').addEventListener('click', drawAssembly);
    document.getElementById('clearAll').addEventListener('click', clearAll);
  </script>
</body>
</html>
